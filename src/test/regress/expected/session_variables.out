-- Set variable
SET @var_int := (SELECT 53);
-- Set multiple variables at once of different types
SET @var_string := 'Text',
    @var_null := NULL,
    @var_date := '2024-05-01',
    @var_array := ARRAY [1,5,3,4],
    @var_int_sci := 7e-5;
-- Selection plus operations with values
SELECT @var_int,
       @var_int + 5,
       @var_int_sci,
       @var_null,
       @var_int IS NULL,
       @var_null IS NULL,
       @var_string,
       @var_string || ' Concat',
       @var_date,
       @var_date::DATE + '1 MONTH'::INTERVAL,
       @var_array,
       (@var_array::anyarray)[2];
 @var_int | ?column? | @var_int_sci | @var_null | ?column? | ?column? | @var_string |  ?column?   | @var_date  |         ?column?         | @var_array | @var_array 
----------+----------+--------------+-----------+----------+----------+-------------+-------------+------------+--------------------------+------------+------------
       53 |       58 |      0.00007 |           | f        | t        | Text        | Text Concat | 2024-05-01 | Sat Jun 01 00:00:00 2024 | {1,5,3,4}  |          5
(1 row)

-- Check that the variable values stayed the same
SELECT @var_string,
       @var_int,
       @var_int_sci,
       @var_null,
       @var_date,
       @var_array;
 @var_string | @var_int | @var_int_sci | @var_null | @var_date  | @var_array 
-------------+----------+--------------+-----------+------------+------------
 Text        |       53 |      0.00007 |           | 2024-05-01 | {1,5,3,4}
(1 row)

-- huge number
SET @huge_num := 18446457440717109658599999999999999999999999999999999999999;
SELECT @huge_num := @huge_num + 2;
                          @huge_num                          
-------------------------------------------------------------
 18446457440717109658600000000000000000000000000000000000001
(1 row)

-- Number by default but convertible to text
SET @num := 5;
SELECT @num;
 @num 
------
    5
(1 row)

SELECT @num::TEXT;
 @num 
------
 5
(1 row)

-- Other way around as well
SET @num := '5';
SELECT @num;
 @num 
------
 5
(1 row)

SELECT @num::INT;
 @num 
------
    5
(1 row)

-- Self assigning
SET @var := 5;
SET @var := (@var * @var) + @var - 1;
SELECT @var;
 @var 
------
   29
(1 row)

SET @sa := @sa + 1; -- should fail
ERROR:  session variable "@sa" does not exist
-- Assigning from variables initiated earlier in the chain
-- Thanks to the pstate->sesvar_changes we don't have to add typecast to
-- @char_int * @created_int previously gained expr types will be assigned to them ->
-- this way parser knows @created_int is an INT even though it has not yet been saved in memory 
-- (the variable is still "not existing" at this point -> if it crashes it won't be saved logically). 
SET @char_int := '5',
    @created_int := @char_int + 3,
    @multiple := @char_int * @created_int;
SELECT @char_int,
       @created_int,
       @multiple;
 @char_int | @created_int | @multiple 
-----------+--------------+-----------
 5         |            8 |        40
(1 row)

SELECT @a := '5',
       @b := @a + 3,
       @c := @a * @b;
 @a | @b | @c 
----+----+----
 5  |  8 | 40
(1 row)

-- Remember inline types
SELECT @dat := '2024-01-01'::DATE,
       @intv := '1 MONTH'::INTERVAL,
       @res := @dat + @intv;
    @dat    |  @intv  |           @res           
------------+---------+--------------------------
 01-01-2024 | @ 1 mon | Thu Feb 01 00:00:00 2024
(1 row)

-- Moreover to sesvar inline type changes
SET @a := 0;
-- The col #3 must not give parser return type INT because we know it will be changed in col before 
SELECT @a, @a := 'hello', @a, @a := 3, @a, @a := 'hello again';
 @a |  @a   |  @a   | @a | @a |     @a      
----+-------+-------+----+----+-------------
  0 | hello | hello |  3 |  3 | hello again
(1 row)

SET @a := 0;
SELECT @a, @a := 'hello', @a, @a := 3, @a, @a := 'hello again' -- should fail;
FROM GENERATE_SERIES(1, 3, 1) num;
ERROR:  invalid input syntax for type integer: "hello again"
SET @a := 0;
SELECT @a, @a := 'hello', @a, @a := 3, @a
FROM GENERATE_SERIES(1, 3, 1) num;
 @a |  @a   |  @a   | @a | @a 
----+-------+-------+----+----
  0 | hello | hello |  3 |  3
  3 | hello | hello |  3 |  3
  3 | hello | hello |  3 |  3
(3 rows)

-- DDL
CREATE TABLE test
(
    col_int  INTEGER,
    col_char VARCHAR(32)
);
-- DML
INSERT INTO test (col_int, col_char)
VALUES (@char_int, @char_int),
       (@multiple / @char_int, @var_string || ' Concat'),
       (6, '5'),
       (6, '5'),
       (6, 'Blocker'),
       (6, 'Blocker'),
       (6, '5'),
       (6, '5'),
       (6, '5');
-- WHERE clause
SELECT *
FROM test
WHERE col_int = @char_int
   OR col_int = @created_int;
 col_int |  col_char   
---------+-------------
       5 | 5
       8 | Text Concat
(2 rows)

-- FROM & LIMIT clause
SELECT *
FROM test t1
         JOIN test t2 ON t1.col_char = @char_int AND t2.col_int = @char_int + 1
LIMIT @char_int - 3;
 col_int | col_char | col_int | col_char 
---------+----------+---------+----------
       5 | 5        |       6 | 5
       5 | 5        |       6 | 5
(2 rows)

-- Aggregated functions
SELECT @min_ci := @b := MIN(col_int) * 2, @max_ci := MAX(col_int) + @b, @b
FROM test;
 @min_ci | @max_ci | @b 
---------+---------+----
      10 |      18 | 10
(1 row)

SELECT col_char, @sum_ci := SUM(col_int)
FROM test
GROUP BY col_char;
  col_char   | @sum_ci 
-------------+---------
 Text Concat |       8
 5           |      35
 Blocker     |      12
(3 rows)

SELECT @sum_ci;
 @sum_ci 
---------
      12
(1 row)

-- Transaction
SET @var := 1;
BEGIN;
SET @var := 2;
ROLLBACK;
SELECT @var;
 @var 
------
    2
(1 row)

SET @pl := 5;
-- DO block
DO
$$
    DECLARE
    BEGIN
        SET @pl := 3;
        ROLLBACK;
    END;
$$ LANGUAGE plpgsql;
SELECT @pl;
 @pl 
-----
   3
(1 row)

DO
$$
    DECLARE
        a INT := 3;
    BEGIN
        SET @pl := a + 3;
    END;
$$ LANGUAGE plpgsql;
SELECT @pl;
 @pl 
-----
   6
(1 row)

SET @pl := 0;
DO
$$
    DECLARE
        i INT;
    BEGIN
        FOR i IN 1..5
            LOOP
                SET @pl := @pl + i;
            END LOOP;
    END;
$$ LANGUAGE plpgsql;
SELECT @pl;
 @pl 
-----
  15
(1 row)

SET @pl := 0;
DO
$$
    DECLARE
        rec RECORD;
    BEGIN
        FOR rec IN SELECT col_int
                   FROM test
            LOOP
                SET @pl := @pl + rec.col_int;
            END LOOP;
    END;
$$ LANGUAGE plpgsql;
SELECT @pl;
 @pl 
-----
  55
(1 row)

-- PROCEDURE
CREATE OR REPLACE PROCEDURE set_session_variables()
AS
$$
DECLARE
BEGIN
    SET @pl := 1;
END;
$$ LANGUAGE plpgsql;
CALL set_session_variables();
SELECT @pl;
 @pl 
-----
   1
(1 row)

DROP PROCEDURE set_session_variables();
CREATE OR REPLACE PROCEDURE set_session_variables_param(a INT)
AS
$$
DECLARE
BEGIN
    SET @pl := 1 + a;
END;
$$ LANGUAGE plpgsql;
CALL set_session_variables_param(5);
SELECT @pl;
 @pl 
-----
   6
(1 row)

DROP PROCEDURE set_session_variables_param;
-- Make sure SESVAR is given to the argument by value to not access freed pointer later on
SET @plpgsql_sv_v := 'abc';
CREATE FUNCTION ffunc()
    RETURNS text AS $$
BEGIN
    RETURN gfunc(@plpgsql_sv_v);
END
$$ LANGUAGE plpgsql;
CREATE FUNCTION gfunc(t text)
    RETURNS text AS $$
BEGIN
    SET @plpgsql_sv_v := 'BOOM!';
    RETURN t;
END;
$$ LANGUAGE plpgsql;
SELECT ffunc();
 ffunc 
-------
 abc
(1 row)

DROP FUNCTION gfunc;
DROP FUNCTION ffunc;
-- SELECT simple assign
SELECT @var_int := 53;
 @var_int 
----------
       53
(1 row)

SELECT @var_string := 'Text',
       @var_null := NULL,
       @var_date := '2024-05-01',
       @var_array := ARRAY [1,5,3,4];
 @var_string | @var_null | @var_date  | @var_array 
-------------+-----------+------------+------------
 Text        |           | 2024-05-01 | {1,5,3,4}
(1 row)

-- Selection plus operations with values
SELECT @var_int,
       @var_int + 5,
       @var_null,
       @var_string,
       @var_string || ' Concat',
       @var_date,
       @var_date::DATE + '1 MONTH'::INTERVAL,
       @var_array,
       (@var_array::anyarray)[2];
 @var_int | ?column? | @var_null | @var_string |  ?column?   | @var_date  |         ?column?         | @var_array | @var_array 
----------+----------+-----------+-------------+-------------+------------+--------------------------+------------+------------
       53 |       58 |           | Text        | Text Concat | 2024-05-01 | Sat Jun 01 00:00:00 2024 | {1,5,3,4}  |          5
(1 row)

SELECT @a := 10,
       @b := 2,
       @a > @b,
       @a := '10',
       @b := 2,
       @a > @b,
       @a := 2,
       @b := 10,
       @a > @b,
       @a := '2',
       @b := '10',
       @a::INT > @b;
 @a | @b | ?column? | @a | @b | ?column? | @a | @b | ?column? | @a | @b | ?column? 
----+----+----------+----+----+----------+----+----+----------+----+----+----------
 10 |  2 | t        | 10 |  2 | t        |  2 | 10 | f        | 2  | 10 | f
(1 row)

-- Collation
SET @txt1 := 'test', @"TXT" := 'TEST';
SELECT @txt1 < @"TXT"; -- should fail
ERROR:  could not determine which collation to use for string comparison
HINT:  Use the COLLATE clause to set the collation explicitly.
SELECT @txt1 < @"TXT" COLLATE "POSIX";
 ?column? 
----------
 f
(1 row)

SELECT @txt1 < @"TXT"; -- should fail
ERROR:  could not determine which collation to use for string comparison
HINT:  Use the COLLATE clause to set the collation explicitly.
SET @"TXT" := 'TEST' COLLATE "POSIX";
SELECT @txt1 < @"TXT";
 ?column? 
----------
 f
(1 row)

-- Expr inside expr
SELECT @t1 := (@t2 := 1) + @t3 := 4,
       @t1,
       @t2,
       @t3 * @t1;
 @t1 | @t1 | @t2 | ?column? 
-----+-----+-----+----------
   5 |   5 |   1 |       20
(1 row)

SELECT @t1 := @t2 := @t3 := 1, @t1, @t2, @t3;
 @t1 | @t1 | @t2 | @t3 
-----+-----+-----+-----
   1 |   1 |   1 |   1
(1 row)

-- Cumulative query
SELECT @t1 := @t1 + (@t2 := @t2 * @t2), @t2 := @t2 + 1
FROM GENERATE_SERIES(1, 3, 1) num;
 @t1 | @t2 
-----+-----
   2 |   2
   6 |   5
  31 |  26
(3 rows)

SET @cum_int := 0,
    @cum_char := 'Hello';
SELECT @cum_int := @cum_int + num, @cum_char := @cum_char || ', hello again'
FROM GENERATE_SERIES(1, 5, 1) num;
 @cum_int |                               @cum_char                                
----------+------------------------------------------------------------------------
        1 | Hello, hello again
        3 | Hello, hello again, hello again
        6 | Hello, hello again, hello again, hello again
       10 | Hello, hello again, hello again, hello again, hello again
       15 | Hello, hello again, hello again, hello again, hello again, hello again
(5 rows)

SELECT @cum_int, @cum_char;
 @cum_int |                               @cum_char                                
----------+------------------------------------------------------------------------
       15 | Hello, hello again, hello again, hello again, hello again, hello again
(1 row)

SET @cum_int := 0,
    @cum_char := 'Hello';
SELECT @cum_int := @cum_int + col_int, @cum_char := @cum_char || ' ' || col_char
FROM test;
 @cum_int |                   @cum_char                   
----------+-----------------------------------------------
        5 | Hello 5
       13 | Hello 5 Text Concat
       19 | Hello 5 Text Concat 5
       25 | Hello 5 Text Concat 5 5
       31 | Hello 5 Text Concat 5 5 Blocker
       37 | Hello 5 Text Concat 5 5 Blocker Blocker
       43 | Hello 5 Text Concat 5 5 Blocker Blocker 5
       49 | Hello 5 Text Concat 5 5 Blocker Blocker 5 5
       55 | Hello 5 Text Concat 5 5 Blocker Blocker 5 5 5
(9 rows)

CREATE OR REPLACE FUNCTION overloaded_text_numeric(str TEXT)
    RETURNS TEXT
AS
$$
BEGIN
    RETURN str || ' Append text';
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION overloaded_text_numeric(str NUMERIC)
    RETURNS TEXT
AS
$$
BEGIN
    RETURN str || ' Append numeric';
END;
$$ LANGUAGE plpgsql;
-- Do automatic cache plan invalidation on type change to ensure correct usage 
DO
$$
    DECLARE
        t TEXT;
    BEGIN
        FOR i IN 1..10
            LOOP
                IF i % 2 = 1 THEN
                    SET @x := 10.5; -- numeric
                ELSE
                    SET @x := 'Ahoj'::TEXT;
                END IF;
                SELECT overloaded_text_numeric(@x) INTO t;
                RAISE NOTICE '%', t;
            END LOOP;
    END;
$$;
NOTICE:  10.5 Append numeric
NOTICE:  Ahoj Append text
NOTICE:  10.5 Append numeric
NOTICE:  Ahoj Append text
NOTICE:  10.5 Append numeric
NOTICE:  Ahoj Append text
NOTICE:  10.5 Append numeric
NOTICE:  Ahoj Append text
NOTICE:  10.5 Append numeric
NOTICE:  Ahoj Append text
DROP FUNCTION overloaded_text_numeric(str TEXT);
DROP FUNCTION overloaded_text_numeric(str NUMERIC);
-- Un/Quoted names
SET @TEST := 2, @test := 5, @"Test" := 3, @"Te.St" := 4;
SELECT @test, @TEST, @"Test", @"Te.St";
 @test | @test | @Test | @Te.St 
-------+-------+-------+--------
     5 |     5 |     3 |      4
(1 row)

SELECT @"tEST"; -- should fail
ERROR:  session variable "@tEST" does not exist
SET "@t" := 5; -- should fail
ERROR:  syntax error at or near ":="
LINE 1: SET "@t" := 5;
                 ^
SET @"@t" := 5;
SELECT @"@t";
 @@t 
-----
   5
(1 row)

-- GROUP/SORT BY without SESVAR EXPR even when specified
-- Grouping by Expr would lead to the grouping sesvar column having potentially different value then the 
-- variable assigning the agg function thus giving us in select two values that doesn't correspond to each other
-- This is because the SESVAR would be assigning each time when preparing the grouped data and not assign the result
-- 
-- We allow beginning with SESVAR to assign the final value but it cannot be nested anywhere else 
SELECT @grp := col_char || ' A', @sum_ci := SUM(col_int)
FROM test
GROUP BY col_char || ' A'
ORDER BY col_char || ' A' DESC;
     @grp      | @sum_ci 
---------------+---------
 Text Concat A |       8
 Blocker A     |      12
 5 A           |      35
(3 rows)

SELECT @grp, @sum_ci;
 @grp | @sum_ci 
------+---------
 5 A  |      35
(1 row)

SELECT @grp := col_char || ' A', @sum_ci := SUM(col_int)
FROM test
GROUP BY 1
ORDER BY 1;
     @grp      | @sum_ci 
---------------+---------
 5 A           |      35
 Blocker A     |      12
 Text Concat A |       8
(3 rows)

SELECT @grp, @sum_ci;
 @grp | @sum_ci 
------+---------
 5 A  |      35
(1 row)

SELECT @grp := col_char, @sum_ci := SUM(col_int)
FROM test
GROUP BY 1;
    @grp     | @sum_ci 
-------------+---------
 Text Concat |       8
 5           |      35
 Blocker     |      12
(3 rows)

SELECT @grp, @sum_ci;
  @grp   | @sum_ci 
---------+---------
 Blocker |      12
(1 row)

SELECT @grp := col_char || ' A', @sum_ci := SUM(col_int)
FROM test
GROUP BY @grp;
     @grp      | @sum_ci 
---------------+---------
 Blocker A     |      12
 Text Concat A |       8
 5 A           |      35
(3 rows)

SELECT @grp, @sum_ci;
 @grp | @sum_ci 
------+---------
 5 A  |      35
(1 row)

SELECT @grp := col_char  || ' A', @sum_ci := SUM(col_int)
FROM test
GROUP BY @grp := col_char  || ' A'
ORDER BY @grp;
     @grp      | @sum_ci 
---------------+---------
 5 A           |      35
 Blocker A     |      12
 Text Concat A |       8
(3 rows)

SELECT @grp, @sum_ci;
 @grp | @sum_ci 
------+---------
 5 A  |      35
(1 row)

SELECT @grp := @grp2 := col_char || ' A', -- should fail
       @sum_ci := SUM(col_int)
FROM test
GROUP BY 1;
ERROR:  Can NOT use SESVAR nested expressions inside GROUP/SORT BY clause.
SELECT @grp := 'S' || @p := 'B' || @grp2 := col_char || ' A', -- should fail
       @sum_ci := SUM(col_int)
FROM test
GROUP BY 1
ORDER BY 1;
ERROR:  Can NOT use SESVAR nested expressions inside GROUP/SORT BY clause.
SELECT col_char || @grp := 'A', @sum_ci := SUM(col_int) -- should fail
FROM test
GROUP BY 1;
ERROR:  Can NOT use SESVAR nested expressions inside GROUP/SORT BY clause.
DROP TABLE test;
